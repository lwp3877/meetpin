/* src/app/api/upload/presigned/route.ts */
// ğŸ” Presigned URL ê¸°ë°˜ ë³´ì•ˆ íŒŒì¼ ì—…ë¡œë“œ

import 'server-only'
import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabaseClient'
import { getAuthenticatedUser, ApiError } from '@/lib/api'
import { rateLimit } from '@/lib/rateLimit'
import { PresignedRequestSchema, type PresignedRequest } from '@/lib/upload/shared'
import { 
  validateFileUploadServer, 
  sanitizeFileNameServer, 
  createUploadSession, 
  getUploadSession, 
  deleteUploadSession,
  type UploadSession 
} from '@/lib/upload/server'

// Next.js Route ì„¤ì •
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
export const revalidate = 0

export async function POST(request: NextRequest) {
  try {
    // Rate limiting: 1ë¶„ì— 10ë²ˆê¹Œì§€
    const ip = request.headers.get('x-forwarded-for') || 
               request.headers.get('x-real-ip') || 
               'unknown'
    const rateLimitResult = await rateLimit(
      `presigned:${ip}`,
      10,
      60 * 1000
    )

    if (!rateLimitResult.success) {
      return NextResponse.json(
        { error: 'Too many upload requests' },
        { 
          status: 429,
          headers: { 'Retry-After': '60' }
        }
      )
    }

    // ì¸ì¦ í™•ì¸
    const user = await getAuthenticatedUser()
    if (!user) {
      throw new ApiError('Authentication required', 401)
    }

    // ìš”ì²­ ë³¸ë¬¸ ê²€ì¦
    const body: PresignedRequest = await request.json()
    const validation = PresignedRequestSchema.safeParse(body)
    
    if (!validation.success) {
      return NextResponse.json(
        { error: 'Invalid request format' },
        { status: 400 }
      )
    }

    const { fileName, fileSize, fileType, uploadType, roomId, reportId } = validation.data

    // íŒŒì¼ ì—…ë¡œë“œ ë³´ì•ˆ ê²€ì¦
    const mockFile = {
      name: fileName,
      size: fileSize,
      type: fileType
    }

    const fileValidation = await validateFileUploadServer(mockFile, uploadType)
    if (!fileValidation.isValid) {
      return NextResponse.json(
        { error: fileValidation.error },
        { status: 400 }
      )
    }

    // ì¶”ê°€ ê¶Œí•œ ê²€ì¦
    const supabase = await createServerSupabaseClient()
    
    if (uploadType === 'roomImage' && roomId) {
      // ë°© í˜¸ìŠ¤íŠ¸ë§Œ ë°© ì´ë¯¸ì§€ ì—…ë¡œë“œ ê°€ëŠ¥
      const { data: room } = await supabase
        .from('rooms')
        .select('host_uid')
        .eq('id', roomId)
        .single()

      if (!room || (room as any).host_uid !== user.id) {
        return NextResponse.json(
          { error: 'Permission denied: Only room host can upload room images' },
          { status: 403 }
        )
      }
    }

    if (uploadType === 'reportFile' && reportId) {
      // ì‹ ê³  ì‘ì„±ìë§Œ ì‹ ê³  íŒŒì¼ ì—…ë¡œë“œ ê°€ëŠ¥
      const { data: report } = await supabase
        .from('reports')
        .select('reporter_id')
        .eq('id', reportId)
        .single()

      if (!report || (report as any).reporter_id !== user.id) {
        return NextResponse.json(
          { error: 'Permission denied: Only report author can upload files' },
          { status: 403 }
        )
      }
    }

    // ê³ ìœ í•œ íŒŒì¼ ê²½ë¡œ ìƒì„±
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2, 8)
    const sanitizedFileName = sanitizeFileNameServer(fileName)
    
    let bucketName: string
    let filePath: string

    switch (uploadType) {
      case 'avatar':
        bucketName = 'avatars'
        filePath = `${user.id}/${timestamp}_${random}_${fileValidation.sanitizedName}`
        break
      
      case 'roomImage':
        bucketName = 'room-images'
        filePath = `${roomId}/${timestamp}_${random}_${fileValidation.sanitizedName}`
        break
      
      case 'reportFile':
        bucketName = 'report-files'
        filePath = `${reportId}/${timestamp}_${random}_${fileValidation.sanitizedName}`
        break
    }

    // Presigned URL ìƒì„± (5ë¶„ ìœ íš¨)
    const { data: presignedData, error: presignedError } = await supabase
      .storage
      .from(bucketName)
      .createSignedUploadUrl(filePath, {
        upsert: false
      })

    if (presignedError) {
      console.error('Presigned URL creation failed:', presignedError)
      throw new ApiError('Failed to create upload URL', 500)
    }

    // ì—…ë¡œë“œ ì„¸ì…˜ ê¸°ë¡ (ì¶”ì ìš©)
    const uploadSession: UploadSession = {
      user_id: user.id,
      file_path: filePath,
      bucket_name: bucketName,
      upload_type: uploadType,
      file_size: fileSize,
      file_type: fileType,
      expires_at: new Date(Date.now() + 5 * 60 * 1000).toISOString(), // 5ë¶„ í›„
      created_at: new Date().toISOString()
    }

    // ì„¸ì…˜ì„ ì„ì‹œ ì €ì¥ (Redis ë“±ì— ì €ì¥ ê¶Œì¥)
    createUploadSession(presignedData.path, uploadSession)

    return NextResponse.json({
      uploadUrl: presignedData.signedUrl,
      filePath: presignedData.path,
      bucketName,
      expiresIn: 300, // 5ë¶„
      maxFileSize: fileSize,
      allowedTypes: uploadType === 'reportFile' 
        ? ['image/jpeg', 'image/png', 'image/webp', 'application/pdf']
        : ['image/jpeg', 'image/png', 'image/webp']
    })

  } catch (error) {
    console.error('Presigned URL creation error:', error)
    
    if (error instanceof ApiError) {
      return NextResponse.json(
        { error: error.message },
        { status: error.status }
      )
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// ì—…ë¡œë“œ ì™„ë£Œ í™•ì¸
export async function PATCH(request: NextRequest) {
  try {
    const user = await getAuthenticatedUser()
    if (!user) {
      throw new ApiError('Authentication required', 401)
    }

    const { filePath } = await request.json()
    
    if (!filePath) {
      return NextResponse.json(
        { error: 'File path required' },
        { status: 400 }
      )
    }

    // ì—…ë¡œë“œ ì„¸ì…˜ í™•ì¸
    const session = getUploadSession(filePath)
    if (!session || session.user_id !== user.id) {
      return NextResponse.json(
        { error: 'Invalid upload session' },
        { status: 400 }
      )
    }

    // íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ í™•ì¸
    const supabase = await createServerSupabaseClient()
    const { data: fileData, error: fileError } = await supabase
      .storage
      .from(session.bucket_name)
      .list(filePath.split('/').slice(0, -1).join('/'), {
        search: filePath.split('/').pop()
      })

    if (fileError || !fileData || fileData.length === 0) {
      return NextResponse.json(
        { error: 'File upload not confirmed' },
        { status: 400 }
      )
    }

    // ì—…ë¡œë“œ ì„¸ì…˜ ì •ë¦¬
    deleteUploadSession(filePath)

    // íŒŒì¼ ê³µê°œ URL ìƒì„±
    const { data: urlData } = supabase
      .storage
      .from(session.bucket_name)
      .getPublicUrl(filePath)

    return NextResponse.json({
      success: true,
      fileUrl: urlData.publicUrl,
      filePath,
      bucketName: session.bucket_name
    })

  } catch (error) {
    console.error('Upload confirmation error:', error)
    
    if (error instanceof ApiError) {
      return NextResponse.json(
        { error: error.message },
        { status: error.status }
      )
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

